## Задания из лабораторной работы:

1. Разработать класс с методами для установки и чтения значения переменной. 
Создать несколько потоков, которые устанавливают значение этой переменной, 
а затем считывают его, выводя информацию об установленном и считанном значениях. 
Продемонстрировать работу этих потоков.

2. Создать несколько потоков, обращающихся к общему списку объектов Integer. 
Потоки устанавливают и считывают значения из него, выводя результаты. 
Продемонстрировать работу потоков без использования и с использованием синхронизации.

3. На основе второго задания продемонстрировать работу потоков с разными приоритетами 
(использовать вывод информации о приоритете).

4. Разработать программу для сортировки массива методом «пузырька» с выводом промежуточных и конечных результатов,
а также времени выполнения. Вычисления выполнять в отдельном потоке, а вывод результатов — в потоке-демоне.

5. Разработать программу для сортировки случайного одномерного массива разными методами (вставка, выбор, пузырек).
Каждый алгоритм сортировки выполняется в отдельном потоке и выводит результаты при каждом новом проходе.

6. Разработать программу для демонстрации ситуации взаимной блокировки (deadlock), 
когда два потока обращаются к массиву значений, приводя к зависанию приложения. 
Затем продемонстрировать, как этого избежать.

7. Создать программу, в которой потоки обращаются к файлу, используя методы wait(), notify(), notifyAll().
Для разработки классов потоков использовать интерфейс Runnable.

8. Разработать программу для создания файла, записи данных и их чтения. 
Обеспечить корректную работу нескольких экземпляров, чтобы запись в конкретную позицию разрешалась 
только одному экземпляру.

9. Разработать приложение, где первый поток генерирует 100 случайных чисел и помещает их в массив. 
Второй поток, выбирая числа из первого массива, вычисляет их синус и добавляет в другой массив, 
поддерживая синхронизацию потоков.

---
# Задание 1
1. Разработать класс с методами для установки и чтения значения переменной.
   Создать несколько потоков, которые устанавливают значение этой переменной,
   а затем считывают его, выводя информацию об установленном и считанном значениях.
   Продемонстрировать работу этих потоков.

```java
public class Main {
    public static void main(String[] args) {
        SharedVariable sharedVariable = new SharedVariable();

        Thread thread1 = new Thread(new VariableWorker(sharedVariable, 10), "Поток 1");
        Thread thread2 = new Thread(new VariableWorker(sharedVariable, 20), "Поток 2");
        Thread thread3 = new Thread(new VariableWorker(sharedVariable, 30), "Поток 3");

        thread1.start();
        thread2.start();
        thread3.start();
    }
}
```

## Result
```txt
Поток 1 установил значение: 10
Поток 1 считал значение: 10
Поток 3 установил значение: 30
Поток 3 считал значение: 30
Поток 2 установил значение: 20
Поток 2 считал значение: 20
Поток 1 завершил работу с считанным значением: 10
Поток 3 завершил работу с считанным значением: 30
Поток 2 завершил работу с считанным значением: 20
```
---
## Задание 2
2. Создать несколько потоков, обращающихся к общему списку объектов Integer.
   Потоки устанавливают и считывают значения из него, выводя результаты.
   Продемонстрировать работу потоков без использования и с использованием синхронизации.

```java
public static void main(String[] args) {
        SharedList sharedList = new SharedList();

        // without synchronized
        System.out.println("Запуск потоков без синхронизации:");
        Thread thread1 = new Thread(new ListWorker(sharedList, 10), "Поток 1");
        Thread thread2 = new Thread(new ListWorker(sharedList, 20), "Поток 2");
        Thread thread3 = new Thread(new ListWorker(sharedList, 30), "Поток 3");

        thread1.start();
        thread2.start();
        thread3.start();

        try {
            thread1.join();
            thread2.join();
            thread3.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("\nЗапуск потоков с синхронизацией:");
        SharedList synchronizedSharedList = new SynchronizedSharedList();

        Thread thread4 = new Thread(new ListWorker(synchronizedSharedList, 10), "Поток 4");
        Thread thread5 = new Thread(new ListWorker(synchronizedSharedList, 20), "Поток 5");
        Thread thread6 = new Thread(new ListWorker(synchronizedSharedList, 30), "Поток 6");

        thread4.start();
        thread5.start();
        thread6.start();
    }
```

```txt
Запуск потоков без синхронизации:
Поток 1 добавил значение: 10
Поток 2 добавил значение: 20
Поток 3 добавил значение: 30
Поток 2 читает значения: [10, 30]
Поток 1 читает значения: [10, 30]
Поток 3 читает значения: [10, 30]

Запуск потоков с синхронизацией:
Поток 4 добавил значение: 10
Поток 4 читает значения: [10]
Поток 5 добавил значение: 20
Поток 5 читает значения: [10, 20]
Поток 6 добавил значение: 30
Поток 6 читает значения: [10, 20, 30]
```
---
## Задание 3
3. На основе второго задания продемонстрировать работу потоков с разными приоритетами
(использовать вывод информации о приоритете).

```java
public static void main(String[] args) {
        SharedList sharedList = new SharedList();

        Thread highPriorityThread = new Thread(new PriorityListWorker(sharedList, 10), "Поток с высоким приоритетом");
        Thread normalPriorityThread = new Thread(new PriorityListWorker(sharedList, 20), "Поток с нормальным приоритетом");
        Thread lowPriorityThread = new Thread(new PriorityListWorker(sharedList, 30), "Поток с низким приоритетом");

        highPriorityThread.setPriority(Thread.MAX_PRIORITY); // 10
        normalPriorityThread.setPriority(Thread.NORM_PRIORITY); // 5
        lowPriorityThread.setPriority(Thread.MIN_PRIORITY); // 1

        highPriorityThread.start();
        normalPriorityThread.start();
        lowPriorityThread.start();

        try {
            highPriorityThread.join();
            normalPriorityThread.join();
            lowPriorityThread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
```

```text
Поток с высоким приоритетом (приоритет: 10) добавил значение: 10
Поток с высоким приоритетом (приоритет: 10) читает значения: [10]
Поток с низким приоритетом (приоритет: 1) добавил значение: 30
Поток с низким приоритетом (приоритет: 1) читает значения: [10, 30]
Поток с нормальным приоритетом (приоритет: 5) добавил значение: 20
Поток с нормальным приоритетом (приоритет: 5) читает значения: [10, 30, 20]
```
---
## Задание 4
4. Разработать программу для сортировки массива методом «пузырька» с выводом промежуточных и конечных результатов,
   а также времени выполнения. Вычисления выполнять в отдельном потоке, а вывод результатов — в потоке-демоне.

```java
public static void main(String[] args) {
        int[] array = {5, 3, 8, 4, 2, 7, 1, 9, 6};
        Object lock = new Object();
        
        BubbleSortTask sortTask = new BubbleSortTask(array, lock);
        
        Thread sortingThread = new Thread(sortTask, "Сортировка");
        
        Thread daemonThread = new Thread(new ResultPrinterDaemon(sortTask, lock), "Демон");
        daemonThread.setDaemon(true); // installing daemon = true
   
        daemonThread.start();
        sortingThread.start();

        // Waiting for the sorting thread to finish
        try {
            sortingThread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
```

```text
Текущий массив: [3, 5, 4, 2, 7, 1, 8, 6, 9](daemon)
Текущий массив: [3, 4, 2, 5, 1, 7, 6, 8, 9](daemon)
Текущий массив: [3, 2, 4, 1, 5, 6, 7, 8, 9](daemon)
Текущий массив: [2, 3, 1, 4, 5, 6, 7, 8, 9](daemon)
Текущий массив: [2, 1, 3, 4, 5, 6, 7, 8, 9](daemon)
Текущий массив: [1, 2, 3, 4, 5, 6, 7, 8, 9](daemon)
Текущий массив: [1, 2, 3, 4, 5, 6, 7, 8, 9](daemon)
Время сортировки: 7001 мс
Текущий массив: [1, 2, 3, 4, 5, 6, 7, 8, 9](daemon)
```

### Потоки-демоны (Daemon Threads) в Java
>Поток-демон в Java - это поток с низким приоритетом, который работает в фоновом режиме для выполнения задач 
> обслуживания или предоставления сервисов для потоков пользователя (user threads).


### Основные характеристики потоков-демонов:
**Время жизни:**
- Поток-демон автоматически завершается, когда все пользовательские потоки завершили свою работу
- JVM завершится, когда останутся только потоки-демоны
### Применение:
- Сборка мусора (Garbage Collection)
- Фоновое сохранение данных
- Мониторинг системы
- Периодическое обслуживание кэша

---
# Задание 5

---

# Задание 6
>Разработать программу для демонстрации ситуации взаимной блокировки (deadlock),
когда два потока обращаются к массиву значений, приводя к зависанию приложения.
Затем продемонстрировать, как этого избежать.
```java
public class Main {
    public static void main(String[] args) {
        // Запуск потоков, создающих deadlock
        System.out.println("Демонстрация deadlock:");
        Thread thread1 = new Thread(new Task1());
        Thread thread2 = new Thread(new Task2());

        thread1.start();
        thread2.start();

        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // Исправление deadlock путем согласования порядка блокировки
        System.out.println("\nИзбежание deadlock:");

        Thread fixedThread1 = new Thread(new FixedTask(true));
        Thread fixedThread2 = new Thread(new FixedTask(false));

        fixedThread1.start();
        fixedThread2.start();
    }
}
```

```text

```
---
# Задание 7
>Создать программу, в которой потоки обращаются к файлу, используя методы wait(), notify(), notifyAll().
Для разработки классов потоков использовать интерфейс Runnable.
```java
public class Main {
    public static void main(String[] args) {
        SharedFile sharedFile = new SharedFile();

        // Создаем потоки для записи и чтения данных
        Thread writerThread1 = new Thread(new Writer(sharedFile, "Данные 1"), "Writer 1");
        Thread writerThread2 = new Thread(new Writer(sharedFile, "Данные 2"), "Writer 2");
        Thread readerThread1 = new Thread(new Reader(sharedFile), "Reader 1");
        Thread readerThread2 = new Thread(new Reader(sharedFile), "Reader 2");

        // Запуск потоков
        writerThread1.start();
        readerThread1.start();
        writerThread2.start();
        readerThread2.start();
    }
}
```

```text
Writer 1 записал: Данные 1
Reader 2 прочитал: [Данные 1]
Writer 2 записал: Данные 2
Reader 1 прочитал: [Данные 1, Данные 2]
```
---

# Задание 8
>Разработать программу для создания файла, записи данных и их чтения.
Обеспечить корректную работу нескольких экземпляров, чтобы запись в конкретную позицию разрешалась
только одному экземпляру.
```java
public class Main {
    public static void main(String[] args) {
        FileManager fileManager = new FileManager();
        
        Thread writer1 = new Thread(new FileWriterTask(fileManager, 1, "Данные 1"), "Writer 1");
        Thread writer2 = new Thread(new FileWriterTask(fileManager, 2, "Данные 2"), "Writer 2");
        Thread writer3 = new Thread(new FileWriterTask(fileManager, 1, "Данные 3 (Конкурент)"), "Writer 3"); // Пытается записать в ту же позицию, что и writer1
        
        Thread reader1 = new Thread(new FileReaderTask(fileManager, 1), "Reader 1");
        Thread reader2 = new Thread(new FileReaderTask(fileManager, 2), "Reader 2");
        
        writer1.start();
        reader1.start();
        writer2.start();
        reader2.start();
        writer3.start();
        
        try {
            writer1.join();
            writer2.join();
            writer3.join();
            reader1.join();
            reader2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Все операции завершены.");
    }
}
```

```text

```
---
# Задание 9
>Разработать приложение, где первый поток генерирует 100 случайных чисел и помещает их в массив.
Второй поток, выбирая числа из первого массива, вычисляет их синус и добавляет в другой массив,
поддерживая синхронизацию потоков.
```java
public class Main {
    public static void main(String[] args) {
        SharedBuffer sharedBuffer = new SharedBuffer();
        
        Thread generatorThread = new Thread(new NumberGenerator(sharedBuffer), "Генератор чисел");
        Thread calculatorThread = new Thread(new SineCalculator(sharedBuffer), "Вычислитель синусов");

        generatorThread.start();
        calculatorThread.start();
        
        try {
            generatorThread.join();
            calculatorThread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```
## Фрагмент результата:
```text
Вычислитель синусов вычислил синус 6: 0.10452846326765347
Вычислитель синусов вычислил синус 28: 0.4694715627858908
Вычислитель синусов вычислил синус 4: 0.0697564737441253
Вычислитель синусов вычислил синус 57: 0.838670567945424
Вычислитель синусов вычислил синус 26: 0.4383711467890774
Вычислитель синусов вычислил синус 54: 0.8090169943749475
Вычислитель синусов вычислил синус 19: 0.3255681544571567
Вычислитель синусов вычислил синус 6: 0.10452846326765347
Вычислитель синусов вычислил синус 16: 0.27563735581699916
Вычислитель синусов вычислил синус 3: 0.052335956242943835
Вычислитель синусов вычислил синус 33: 0.5446390350150271
Результаты синусов: [0.9961946980917455, 0.9781476007338056, 0.898794046299167, 0.9998476951563913, 0.7313537016191705, 0.8746197071393957, 0.8191520442889918, 0.981627183447664, 0.9925461516413221, 0.9876883405951378, 0.9945218953682733, 0.45399049973954675, 0.3420201433256687, 0.29237170472273677, 0.9135454576426009, 0.7431448254773942, 0.7313537016191705, 0.9510565162951535, 0.8910065241883678, 0.9205048534524404, 0.8571673007021123, 0.08715574274765817, 0.9396926207859083, 0.6946583704589973, 0.03489949670250097, 0.9975640502598242, 0.9876883405951378, 0.9902680687415704, 0.992546151641322, 0.9993908270190958, 0.3420201433256687, 0.9335804264972017, 0.9612616959383189, 0.984807753012208, 0.9781476007338056, 0.13917310096006544, 0.5150380749100542, 0.9986295347545738, 0.8191520442889918, 0.35836794954530027, 0.9876883405951378, 0.788010753606722, 0.8746197071393957, 0.03489949670250097, 0.4694715627858908, 0.848048096156426, 0.35836794954530027, 0.9925461516413221, 0.7771459614569709, 0.8290375725550417, 0.01745240643728351, 0.0697564737441253, 0.9986295347545738, 0.9975640502598242, 0.9986295347545738, 0.20791169081775934, 0.0, 0.9961946980917455, 0.8191520442889918, 0.12186934340514748, 0.48480962024633706, 0.6018150231520483, 1.0, 0.374606593415912, 0.7313537016191705, 0.3090169943749474, 0.6560590289905073, 0.9702957262759965, 0.8290375725550417, 0.6427876096865393, 0.24192189559966773, 0.224951054343865, 0.35836794954530027, 0.25881904510252074, 0.03489949670250097, 0.5591929034707469, 0.4067366430758002, 0.13917310096006544, 0.9876883405951378, 0.9975640502598242, 0.8090169943749475, 0.9612616959383189, 0.3420201433256687, 0.9271838545667874, 0.7071067811865475, 0.9876883405951378, 0.0697564737441253, 0.6427876096865393, 0.8090169943749475, 0.10452846326765347, 0.4694715627858908, 0.0697564737441253, 0.838670567945424, 0.4383711467890774, 0.8090169943749475, 0.3255681544571567, 0.10452846326765347, 0.27563735581699916, 0.052335956242943835, 0.5446390350150271]
Все операции завершены.
```
